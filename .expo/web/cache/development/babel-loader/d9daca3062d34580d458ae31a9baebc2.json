{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nimport { NativeReanimated } from \"../NativeReanimated/NativeReanimated\";\nimport { SensorType } from \"../commonTypes\";\n\nvar JSReanimated = function (_NativeReanimated) {\n  _inherits(JSReanimated, _NativeReanimated);\n\n  var _super = _createSuper(JSReanimated);\n\n  function JSReanimated() {\n    var _this;\n\n    _classCallCheck(this, JSReanimated);\n\n    _this = _super.call(this, false);\n\n    _defineProperty(_assertThisInitialized(_this), \"nextSensorId\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"sensors\", new Map());\n\n    return _this;\n  }\n\n  _createClass(JSReanimated, [{\n    key: \"makeShareableClone\",\n    value: function makeShareableClone(value) {\n      return {\n        __hostObjectShareableJSRef: value\n      };\n    }\n  }, {\n    key: \"installCoreFunctions\",\n    value: function installCoreFunctions(_callGuard, _valueUnpacker) {}\n  }, {\n    key: \"scheduleOnUI\",\n    value: function scheduleOnUI(worklet) {\n      requestAnimationFrame(worklet);\n    }\n  }, {\n    key: \"registerEventHandler\",\n    value: function registerEventHandler(_eventHash, _eventHandler) {\n      return '';\n    }\n  }, {\n    key: \"unregisterEventHandler\",\n    value: function unregisterEventHandler(_) {}\n  }, {\n    key: \"enableLayoutAnimations\",\n    value: function enableLayoutAnimations() {\n      console.warn('[Reanimated] Layout Animations are not supported on web yet.');\n    }\n  }, {\n    key: \"configureLayoutAnimation\",\n    value: function configureLayoutAnimation() {}\n  }, {\n    key: \"registerSensor\",\n    value: function registerSensor(sensorType, interval, iosReferenceFrame, eventHandler) {\n      if (!(this.getSensorName(sensorType) in window)) {\n        return -1;\n      }\n\n      var sensor = this.initializeSensor(sensorType, interval);\n      var callback;\n\n      if (sensorType === SensorType.ROTATION) {\n        callback = function callback() {\n          var _sensor$quaternion = _slicedToArray(sensor.quaternion, 4),\n              qw = _sensor$quaternion[0],\n              qx = _sensor$quaternion[1],\n              qy = _sensor$quaternion[2],\n              qz = _sensor$quaternion[3];\n\n          var yaw = Math.atan2(2.0 * (qy * qz + qw * qx), qw * qw - qx * qx - qy * qy + qz * qz);\n          var pitch = Math.sin(-2.0 * (qx * qz - qw * qy));\n          var roll = Math.atan2(2.0 * (qx * qy + qw * qz), qw * qw + qx * qx - qy * qy - qz * qz);\n          eventHandler({\n            qw: qw,\n            qx: qx,\n            qy: qy,\n            qz: qz,\n            yaw: yaw,\n            pitch: pitch,\n            roll: roll,\n            interfaceOrientation: 0\n          });\n        };\n      } else {\n        callback = function callback() {\n          var x = sensor.x,\n              y = sensor.y,\n              z = sensor.z;\n          eventHandler({\n            x: x,\n            y: y,\n            z: z,\n            interfaceOrientation: 0\n          });\n        };\n      }\n\n      sensor.addEventListener('reading', callback);\n      sensor.start();\n      this.sensors.set(this.nextSensorId, sensor);\n      return this.nextSensorId++;\n    }\n  }, {\n    key: \"unregisterSensor\",\n    value: function unregisterSensor(id) {\n      var sensor = this.sensors.get(id);\n\n      if (sensor !== undefined) {\n        sensor.stop();\n        this.sensors.delete(id);\n      }\n    }\n  }, {\n    key: \"subscribeForKeyboardEvents\",\n    value: function subscribeForKeyboardEvents(_) {\n      console.warn('[Reanimated] useAnimatedKeyboard is not available on web yet.');\n      return -1;\n    }\n  }, {\n    key: \"unsubscribeFromKeyboardEvents\",\n    value: function unsubscribeFromKeyboardEvents(_) {}\n  }, {\n    key: \"initializeSensor\",\n    value: function initializeSensor(sensorType, interval) {\n      var config = interval <= 0 ? {\n        referenceFrame: 'device'\n      } : {\n        frequency: 1000 / interval\n      };\n\n      switch (sensorType) {\n        case SensorType.ACCELEROMETER:\n          return new window.Accelerometer(config);\n\n        case SensorType.GYROSCOPE:\n          return new window.Gyroscope(config);\n\n        case SensorType.GRAVITY:\n          return new window.GravitySensor(config);\n\n        case SensorType.MAGNETIC_FIELD:\n          return new window.Magnetometer(config);\n\n        case SensorType.ROTATION:\n          return new window.AbsoluteOrientationSensor(config);\n      }\n    }\n  }, {\n    key: \"getSensorName\",\n    value: function getSensorName(sensorType) {\n      switch (sensorType) {\n        case SensorType.ACCELEROMETER:\n          return 'Accelerometer';\n\n        case SensorType.GRAVITY:\n          return 'GravitySensor';\n\n        case SensorType.GYROSCOPE:\n          return 'Gyroscope';\n\n        case SensorType.MAGNETIC_FIELD:\n          return 'Magnetometer';\n\n        case SensorType.ROTATION:\n          return 'AbsoluteOrientationSensor';\n      }\n    }\n  }]);\n\n  return JSReanimated;\n}(NativeReanimated);\n\nexport { JSReanimated as default };","map":{"version":3,"sources":["JSReanimated.ts"],"names":["NativeReanimated","SensorType","JSReanimated","_defineProperty","Map","constructor","makeShareableClone","value","__hostObjectShareableJSRef","installCoreFunctions","_callGuard","_valueUnpacker","scheduleOnUI","worklet","requestAnimationFrame","registerEventHandler","_eventHash","_eventHandler","unregisterEventHandler","_","enableLayoutAnimations","console","warn","configureLayoutAnimation","registerSensor","sensorType","interval","iosReferenceFrame","eventHandler","getSensorName","window","sensor","initializeSensor","callback","ROTATION","qw","qx","qy","qz","quaternion","yaw","Math","atan2","pitch","sin","roll","interfaceOrientation","x","y","z","addEventListener","start","sensors","set","nextSensorId","unregisterSensor","id","get","undefined","stop","delete","subscribeForKeyboardEvents","unsubscribeFromKeyboardEvents","config","referenceFrame","frequency","ACCELEROMETER","Accelerometer","GYROSCOPE","Gyroscope","GRAVITY","GravitySensor","MAGNETIC_FIELD","Magnetometer","AbsoluteOrientationSensor"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,gBAAT;AACA,SACEC,UADF;;IAQqBC,Y;;;;;EAInBG,wBAAc;IAAA;;IAAA;;IACZ,0BAAM,KAAN;;IAAaF,eAAAA,gCAAAA,cAAAA,EAJA,CAIAA,CAAAA;;IAJCA,eAAAA,gCAAAA,SAAAA,EACN,IAAIC,GAAJ,EADMD,CAAAA;;IAGF;EAEd;;;;WAEAG,4BAAsBC,KAAtBD,EAAiD;MAC/C,OAAO;QAAEE,0BAA0B,EAAED;MAA9B,CAAP;IACF;;;WAEAE,8BACEC,UADFD,EAKEE,cALFF,EAMQ,CACN;;;WAGFG,sBAAgBC,OAAhBD,EAA0C;MAExCE,qBAAqB,CAACD,OAAD,CAArBC;IACF;;;WAEAC,8BACEC,UADFD,EAEEE,aAFFF,EAGU;MAER,OAAO,EAAP;IACF;;;WAEAG,gCAAuBC,CAAvBD,EAAwC,CACtC;;;WAGFE,kCAAyB;MACvBC,OAAO,CAACC,IAARD,CACE,8DADFA;IAGF;;;WAEAE,oCAA2B,CACzB;;;WAGFC,wBACEC,UADFD,EAEEE,QAFFF,EAGEG,iBAHFH,EAIEI,YAJFJ,EAKU;MACR,IAAI,EAAE,KAAKK,aAAL,CAAmBJ,UAAnB,KAAkCK,MAApC,CAAJ,EAAiD;QAC/C,OAAO,CAAC,CAAR;MACF;;MAEA,IAAMC,MAAiB,GAAG,KAAKC,gBAAL,CAAsBP,UAAtB,EAAkCC,QAAlC,CAA1B;MACA,IAAIO,QAAJ;;MACA,IAAIR,UAAU,KAAKxB,UAAU,CAACiC,QAA9B,EAAwC;QACtCD,QAAQ,GAAGA,oBAAM;UACf,wCAAyBF,MAAM,CAACQ,UAAhC;UAAA,IAAOJ,EAAP;UAAA,IAAWC,EAAX;UAAA,IAAeC,EAAf;UAAA,IAAmBC,EAAnB;;UAGA,IAAME,GAAG,GAAGC,IAAI,CAACC,KAALD,CACV,OAAOJ,EAAE,GAAGC,EAALD,GAAUF,EAAE,GAAGC,EAAtB,CADUK,EAEVN,EAAE,GAAGA,EAALA,GAAUC,EAAE,GAAGA,EAAfD,GAAoBE,EAAE,GAAGA,EAAzBF,GAA8BG,EAAE,GAAGA,EAFzBG,CAAZ;UAIA,IAAME,KAAK,GAAGF,IAAI,CAACG,GAALH,CAAS,CAAC,GAAD,IAAQL,EAAE,GAAGE,EAALF,GAAUD,EAAE,GAAGE,EAAvB,CAATI,CAAd;UACA,IAAMI,IAAI,GAAGJ,IAAI,CAACC,KAALD,CACX,OAAOL,EAAE,GAAGC,EAALD,GAAUD,EAAE,GAAGG,EAAtB,CADWG,EAEXN,EAAE,GAAGA,EAALA,GAAUC,EAAE,GAAGA,EAAfD,GAAoBE,EAAE,GAAGA,EAAzBF,GAA8BG,EAAE,GAAGA,EAFxBG,CAAb;UAIAb,YAAY,CAAC;YACXO,EAAE,EAAFA,EADW;YAEXC,EAAE,EAAFA,EAFW;YAGXC,EAAE,EAAFA,EAHW;YAIXC,EAAE,EAAFA,EAJW;YAKXE,GAAG,EAAHA,GALW;YAMXG,KAAK,EAALA,KANW;YAOXE,IAAI,EAAJA,IAPW;YAQXC,oBAAoB,EAAE;UARX,CAAD,CAAZlB;QAUD,CAvBDK;MAwBD,CAzBD,MAyBO;QACLA,QAAQ,GAAGA,oBAAM;UACf,IAAQc,CAAR,GAAoBhB,MAApB,CAAQgB,CAAR;UAAA,IAAWC,CAAX,GAAoBjB,MAApB,CAAWiB,CAAX;UAAA,IAAcC,CAAd,GAAoBlB,MAApB,CAAckB,CAAd;UACArB,YAAY,CAAC;YAAEmB,CAAC,EAADA,CAAF;YAAKC,CAAC,EAADA,CAAL;YAAQC,CAAC,EAADA,CAAR;YAAWH,oBAAoB,EAAE;UAAjC,CAAD,CAAZlB;QACD,CAHDK;MAIF;;MACAF,MAAM,CAACmB,gBAAPnB,CAAwB,SAAxBA,EAAmCE,QAAnCF;MACAA,MAAM,CAACoB,KAAPpB;MAEA,KAAKqB,OAAL,CAAaC,GAAb,CAAiB,KAAKC,YAAtB,EAAoCvB,MAApC;MACA,OAAO,KAAKuB,YAAL,EAAP;IACF;;;WAEAC,0BAAiBC,EAAjBD,EAAmC;MACjC,IAAMxB,MAA6B,GAAG,KAAKqB,OAAL,CAAaK,GAAb,CAAiBD,EAAjB,CAAtC;;MACA,IAAIzB,MAAM,KAAK2B,SAAf,EAA0B;QACxB3B,MAAM,CAAC4B,IAAP5B;QACA,KAAKqB,OAAL,CAAaQ,MAAb,CAAoBJ,EAApB;MACF;IACF;;;WAEAK,oCAA2B1C,CAA3B0C,EAA4D;MAC1DxC,OAAO,CAACC,IAARD,CACE,+DADFA;MAGA,OAAO,CAAC,CAAR;IACF;;;WAEAyC,uCAA8B3C,CAA9B2C,EAA+C,CAC7C;;;WAGF9B,0BAAiBP,UAAjBO,EAAyCN,QAAzCM,EAAsE;MACpE,IAAM+B,MAAM,GACVrC,QAAQ,IAAI,CAAZA,GACI;QAAEsC,cAAc,EAAE;MAAlB,CADJtC,GAEI;QAAEuC,SAAS,EAAE,OAAOvC;MAApB,CAHN;;MAIA,QAAQD,UAAR;QACE,KAAKxB,UAAU,CAACiE,aAAhB;UACE,OAAO,IAAIpC,MAAM,CAACqC,aAAX,CAAyBJ,MAAzB,CAAP;;QACF,KAAK9D,UAAU,CAACmE,SAAhB;UACE,OAAO,IAAItC,MAAM,CAACuC,SAAX,CAAqBN,MAArB,CAAP;;QACF,KAAK9D,UAAU,CAACqE,OAAhB;UACE,OAAO,IAAIxC,MAAM,CAACyC,aAAX,CAAyBR,MAAzB,CAAP;;QACF,KAAK9D,UAAU,CAACuE,cAAhB;UACE,OAAO,IAAI1C,MAAM,CAAC2C,YAAX,CAAwBV,MAAxB,CAAP;;QACF,KAAK9D,UAAU,CAACiC,QAAhB;UACE,OAAO,IAAIJ,MAAM,CAAC4C,yBAAX,CAAqCX,MAArC,CAAP;MAVJ;IAYF;;;WAEAlC,uBAAcJ,UAAdI,EAA8C;MAC5C,QAAQJ,UAAR;QACE,KAAKxB,UAAU,CAACiE,aAAhB;UACE,OAAO,eAAP;;QACF,KAAKjE,UAAU,CAACqE,OAAhB;UACE,OAAO,eAAP;;QACF,KAAKrE,UAAU,CAACmE,SAAhB;UACE,OAAO,WAAP;;QACF,KAAKnE,UAAU,CAACuE,cAAhB;UACE,OAAO,cAAP;;QACF,KAAKvE,UAAU,CAACiC,QAAhB;UACE,OAAO,2BAAP;MAVJ;IAYF;;;;EAtJwClC,gB;;SAArBE,Y","sourcesContent":["import { NativeReanimated } from '../NativeReanimated/NativeReanimated';\nimport {\n  SensorType,\n  ShareableRef,\n  Value3D,\n  ValueRotation,\n} from '../commonTypes';\nimport { WebSensor } from './WebSensor';\n\nexport default class JSReanimated extends NativeReanimated {\n  nextSensorId = 0;\n  sensors = new Map<number, WebSensor>();\n\n  constructor() {\n    super(false);\n  }\n\n  makeShareableClone<T>(value: T): ShareableRef<T> {\n    return { __hostObjectShareableJSRef: value };\n  }\n\n  installCoreFunctions(\n    _callGuard: <T extends Array<any>, U>(\n      fn: (...args: T) => U,\n      ...args: T\n    ) => void,\n    _valueUnpacker: <T>(value: T) => T\n  ): void {\n    // noop\n  }\n\n  scheduleOnUI<T>(worklet: ShareableRef<T>) {\n    // @ts-ignore web implementation has still not been updated after the rewrite, this will be addressed once the web implementation updates are ready\n    requestAnimationFrame(worklet);\n  }\n\n  registerEventHandler<T>(\n    _eventHash: string,\n    _eventHandler: ShareableRef<T>\n  ): string {\n    // noop\n    return '';\n  }\n\n  unregisterEventHandler(_: string): void {\n    // noop\n  }\n\n  enableLayoutAnimations() {\n    console.warn(\n      '[Reanimated] Layout Animations are not supported on web yet.'\n    );\n  }\n\n  configureLayoutAnimation() {\n    // no-op\n  }\n\n  registerSensor(\n    sensorType: SensorType,\n    interval: number,\n    iosReferenceFrame: number,\n    eventHandler: (data: Value3D | ValueRotation) => void\n  ): number {\n    if (!(this.getSensorName(sensorType) in window)) {\n      return -1;\n    }\n\n    const sensor: WebSensor = this.initializeSensor(sensorType, interval);\n    let callback;\n    if (sensorType === SensorType.ROTATION) {\n      callback = () => {\n        const [qw, qx, qy, qz] = sensor.quaternion;\n\n        // reference: https://stackoverflow.com/questions/5782658/extracting-yaw-from-a-quaternion\n        const yaw = Math.atan2(\n          2.0 * (qy * qz + qw * qx),\n          qw * qw - qx * qx - qy * qy + qz * qz\n        );\n        const pitch = Math.sin(-2.0 * (qx * qz - qw * qy));\n        const roll = Math.atan2(\n          2.0 * (qx * qy + qw * qz),\n          qw * qw + qx * qx - qy * qy - qz * qz\n        );\n        eventHandler({\n          qw,\n          qx,\n          qy,\n          qz,\n          yaw,\n          pitch,\n          roll,\n          interfaceOrientation: 0,\n        });\n      };\n    } else {\n      callback = () => {\n        const { x, y, z } = sensor;\n        eventHandler({ x, y, z, interfaceOrientation: 0 });\n      };\n    }\n    sensor.addEventListener('reading', callback);\n    sensor.start();\n\n    this.sensors.set(this.nextSensorId, sensor);\n    return this.nextSensorId++;\n  }\n\n  unregisterSensor(id: number): void {\n    const sensor: WebSensor | undefined = this.sensors.get(id);\n    if (sensor !== undefined) {\n      sensor.stop();\n      this.sensors.delete(id);\n    }\n  }\n\n  subscribeForKeyboardEvents(_: ShareableRef<number>): number {\n    console.warn(\n      '[Reanimated] useAnimatedKeyboard is not available on web yet.'\n    );\n    return -1;\n  }\n\n  unsubscribeFromKeyboardEvents(_: number): void {\n    // noop\n  }\n\n  initializeSensor(sensorType: SensorType, interval: number): WebSensor {\n    const config =\n      interval <= 0\n        ? { referenceFrame: 'device' }\n        : { frequency: 1000 / interval };\n    switch (sensorType) {\n      case SensorType.ACCELEROMETER:\n        return new window.Accelerometer(config);\n      case SensorType.GYROSCOPE:\n        return new window.Gyroscope(config);\n      case SensorType.GRAVITY:\n        return new window.GravitySensor(config);\n      case SensorType.MAGNETIC_FIELD:\n        return new window.Magnetometer(config);\n      case SensorType.ROTATION:\n        return new window.AbsoluteOrientationSensor(config);\n    }\n  }\n\n  getSensorName(sensorType: SensorType): string {\n    switch (sensorType) {\n      case SensorType.ACCELEROMETER:\n        return 'Accelerometer';\n      case SensorType.GRAVITY:\n        return 'GravitySensor';\n      case SensorType.GYROSCOPE:\n        return 'Gyroscope';\n      case SensorType.MAGNETIC_FIELD:\n        return 'Magnetometer';\n      case SensorType.ROTATION:\n        return 'AbsoluteOrientationSensor';\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}