{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar Vector = function () {\n  function Vector(length) {\n    _classCallCheck(this, Vector);\n\n    _defineProperty(this, \"offset\", void 0);\n\n    _defineProperty(this, \"length\", void 0);\n\n    _defineProperty(this, \"elements\", void 0);\n\n    this.offset = 0;\n    this.length = length;\n    this.elements = new Array(length);\n  }\n\n  _createClass(Vector, [{\n    key: \"get\",\n    value: function get(index) {\n      return this.elements[this.offset + index];\n    }\n  }, {\n    key: \"set\",\n    value: function set(index, value) {\n      this.elements[this.offset + index] = value;\n    }\n  }, {\n    key: \"dot\",\n    value: function dot(other) {\n      var result = 0;\n\n      for (var i = 0; i < this.length; i++) {\n        result += this.get(i) * other.get(i);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"norm\",\n    value: function norm() {\n      return Math.sqrt(this.dot(this));\n    }\n  }], [{\n    key: \"fromVOL\",\n    value: function fromVOL(values, offset, length) {\n      var result = new Vector(0);\n      result.offset = offset;\n      result.length = length;\n      result.elements = values;\n      return result;\n    }\n  }]);\n\n  return Vector;\n}();\n\nvar Matrix = function () {\n  function Matrix(rows, columns) {\n    _classCallCheck(this, Matrix);\n\n    _defineProperty(this, \"columns\", void 0);\n\n    _defineProperty(this, \"elements\", void 0);\n\n    this.columns = columns;\n    this.elements = new Array(rows * columns);\n  }\n\n  _createClass(Matrix, [{\n    key: \"get\",\n    value: function get(row, column) {\n      return this.elements[row * this.columns + column];\n    }\n  }, {\n    key: \"set\",\n    value: function set(row, column, value) {\n      this.elements[row * this.columns + column] = value;\n    }\n  }, {\n    key: \"getRow\",\n    value: function getRow(row) {\n      return Vector.fromVOL(this.elements, row * this.columns, this.columns);\n    }\n  }]);\n\n  return Matrix;\n}();\n\nvar PolynomialFit = _createClass(function PolynomialFit(degree) {\n  _classCallCheck(this, PolynomialFit);\n\n  _defineProperty(this, \"coefficients\", void 0);\n\n  this.coefficients = new Array(degree + 1);\n});\n\nvar precisionErrorTolerance = 1e-10;\n\nvar LeastSquareSolver = function () {\n  function LeastSquareSolver(x, y, w) {\n    _classCallCheck(this, LeastSquareSolver);\n\n    _defineProperty(this, \"x\", void 0);\n\n    _defineProperty(this, \"y\", void 0);\n\n    _defineProperty(this, \"w\", void 0);\n\n    this.x = x;\n    this.y = y;\n    this.w = w;\n  }\n\n  _createClass(LeastSquareSolver, [{\n    key: \"solve\",\n    value: function solve(degree) {\n      if (degree > this.x.length) {\n        return null;\n      }\n\n      var result = new PolynomialFit(degree);\n      var m = this.x.length;\n      var n = degree + 1;\n      var a = new Matrix(n, m);\n\n      for (var h = 0; h < m; h++) {\n        a.set(0, h, this.w[h]);\n\n        for (var i = 1; i < n; i++) {\n          a.set(i, h, a.get(i - 1, h) * this.x[h]);\n        }\n      }\n\n      var q = new Matrix(n, m);\n      var r = new Matrix(n, m);\n\n      for (var j = 0; j < n; j += 1) {\n        for (var _h2 = 0; _h2 < m; _h2 += 1) {\n          q.set(j, _h2, a.get(j, _h2));\n        }\n\n        for (var _i2 = 0; _i2 < j; _i2 += 1) {\n          var dot = q.getRow(j).dot(q.getRow(_i2));\n\n          for (var _h4 = 0; _h4 < m; _h4 += 1) {\n            q.set(j, _h4, q.get(j, _h4) - dot * q.get(_i2, _h4));\n          }\n        }\n\n        var norm = q.getRow(j).norm();\n\n        if (norm < precisionErrorTolerance) {\n          return null;\n        }\n\n        var inverseNorm = 1.0 / norm;\n\n        for (var _h6 = 0; _h6 < m; _h6 += 1) {\n          q.set(j, _h6, q.get(j, _h6) * inverseNorm);\n        }\n\n        for (var _i4 = 0; _i4 < n; _i4 += 1) {\n          r.set(j, _i4, _i4 < j ? 0.0 : q.getRow(j).dot(a.getRow(_i4)));\n        }\n      }\n\n      var wy = new Vector(m);\n\n      for (var _h8 = 0; _h8 < m; _h8 += 1) {\n        wy.set(_h8, this.y[_h8] * this.w[_h8]);\n      }\n\n      for (var _i6 = n - 1; _i6 >= 0; _i6 -= 1) {\n        result.coefficients[_i6] = q.getRow(_i6).dot(wy);\n\n        for (var _j2 = n - 1; _j2 > _i6; _j2 -= 1) {\n          result.coefficients[_i6] -= r.get(_i6, _j2) * result.coefficients[_j2];\n        }\n\n        result.coefficients[_i6] /= r.get(_i6, _i6);\n      }\n\n      return result;\n    }\n  }]);\n\n  return LeastSquareSolver;\n}();\n\nexport { LeastSquareSolver as default };","map":{"version":3,"sources":["LeastSquareSolver.ts"],"names":["constructor","fromVOL","result","get","set","dot","i","other","norm","Math","rows","row","getRow","Vector","degree","precisionErrorTolerance","solve","m","n","a","h","q","r","j","inverseNorm","wy"],"mappings":"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","sourcesContent":["// Implementation taken from Flutter's LeastSquareSolver\n// https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/gestures/lsq_solver.dart\n\nclass Vector {\n  private offset: number;\n  private length: number;\n  private elements: number[];\n\n  constructor(length: number) {\n    this.offset = 0;\n    this.length = length;\n    this.elements = new Array<number>(length);\n  }\n\n  public static fromVOL(\n    values: number[],\n    offset: number,\n    length: number\n  ): Vector {\n    const result = new Vector(0);\n\n    result.offset = offset;\n    result.length = length;\n    result.elements = values;\n\n    return result;\n  }\n\n  public get(index: number): number {\n    return this.elements[this.offset + index];\n  }\n\n  public set(index: number, value: number): void {\n    this.elements[this.offset + index] = value;\n  }\n\n  public dot(other: Vector): number {\n    let result = 0;\n    for (let i = 0; i < this.length; i++) {\n      result += this.get(i) * other.get(i);\n    }\n    return result;\n  }\n\n  public norm() {\n    return Math.sqrt(this.dot(this));\n  }\n}\n\nclass Matrix {\n  private columns: number;\n  private elements: number[];\n\n  constructor(rows: number, columns: number) {\n    this.columns = columns;\n    this.elements = new Array<number>(rows * columns);\n  }\n\n  public get(row: number, column: number): number {\n    return this.elements[row * this.columns + column];\n  }\n\n  public set(row: number, column: number, value: number): void {\n    this.elements[row * this.columns + column] = value;\n  }\n\n  public getRow(row: number): Vector {\n    return Vector.fromVOL(this.elements, row * this.columns, this.columns);\n  }\n}\n\n/// An nth degree polynomial fit to a dataset.\nclass PolynomialFit {\n  /// The polynomial coefficients of the fit.\n  ///\n  /// For each `i`, the element `coefficients[i]` is the coefficient of\n  /// the `i`-th power of the variable.\n  public coefficients: number[];\n\n  /// Creates a polynomial fit of the given degree.\n  ///\n  /// There are n + 1 coefficients in a fit of degree n.\n  constructor(degree: number) {\n    this.coefficients = new Array<number>(degree + 1);\n  }\n}\n\nconst precisionErrorTolerance = 1e-10;\n\n/// Uses the least-squares algorithm to fit a polynomial to a set of data.\nexport default class LeastSquareSolver {\n  /// The x-coordinates of each data point.\n  private x: number[];\n  /// The y-coordinates of each data point.\n  private y: number[];\n  /// The weight to use for each data point.\n  private w: number[];\n\n  /// Creates a least-squares solver.\n  ///\n  /// The [x], [y], and [w] arguments must not be null.\n  constructor(x: number[], y: number[], w: number[]) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n  }\n\n  /// Fits a polynomial of the given degree to the data points.\n  ///\n  /// When there is not enough data to fit a curve null is returned.\n  public solve(degree: number): PolynomialFit | null {\n    if (degree > this.x.length) {\n      // Not enough data to fit a curve.\n      return null;\n    }\n\n    const result = new PolynomialFit(degree);\n\n    // Shorthands for the purpose of notation equivalence to original C++ code.\n    const m = this.x.length;\n    const n = degree + 1;\n\n    // Expand the X vector to a matrix A, pre-multiplied by the weights.\n    const a = new Matrix(n, m);\n    for (let h = 0; h < m; h++) {\n      a.set(0, h, this.w[h]);\n\n      for (let i = 1; i < n; i++) {\n        a.set(i, h, a.get(i - 1, h) * this.x[h]);\n      }\n    }\n\n    // Apply the Gram-Schmidt process to A to obtain its QR decomposition.\n\n    // Orthonormal basis, column-major ordVectorer.\n    const q = new Matrix(n, m);\n    // Upper triangular matrix, row-major order.\n    const r = new Matrix(n, m);\n\n    for (let j = 0; j < n; j += 1) {\n      for (let h = 0; h < m; h += 1) {\n        q.set(j, h, a.get(j, h));\n      }\n      for (let i = 0; i < j; i += 1) {\n        const dot = q.getRow(j).dot(q.getRow(i));\n        for (let h = 0; h < m; h += 1) {\n          q.set(j, h, q.get(j, h) - dot * q.get(i, h));\n        }\n      }\n\n      const norm = q.getRow(j).norm();\n      if (norm < precisionErrorTolerance) {\n        // Vectors are linearly dependent or zero so no solution.\n        return null;\n      }\n\n      const inverseNorm = 1.0 / norm;\n      for (let h = 0; h < m; h += 1) {\n        q.set(j, h, q.get(j, h) * inverseNorm);\n      }\n      for (let i = 0; i < n; i += 1) {\n        r.set(j, i, i < j ? 0.0 : q.getRow(j).dot(a.getRow(i)));\n      }\n    }\n\n    // Solve R B = Qt W Y to find B. This is easy because R is upper triangular.\n    // We just work from bottom-right to top-left calculating B's coefficients.\n    const wy = new Vector(m);\n    for (let h = 0; h < m; h += 1) {\n      wy.set(h, this.y[h] * this.w[h]);\n    }\n    for (let i = n - 1; i >= 0; i -= 1) {\n      result.coefficients[i] = q.getRow(i).dot(wy);\n      for (let j = n - 1; j > i; j -= 1) {\n        result.coefficients[i] -= r.get(i, j) * result.coefficients[j];\n      }\n      result.coefficients[i] /= r.get(i, i);\n    }\n\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}