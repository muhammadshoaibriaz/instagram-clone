{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nvar _workletStackDetails = new Map();\n\nexport function registerWorkletStackDetails(hash, stackDetails) {\n  _workletStackDetails.set(hash, stackDetails);\n}\n\nfunction getBundleOffset(error) {\n  var _error$stack, _error$stack$split;\n\n  var frame = (_error$stack = error.stack) === null || _error$stack === void 0 ? void 0 : (_error$stack$split = _error$stack.split('\\n')) === null || _error$stack$split === void 0 ? void 0 : _error$stack$split[0];\n\n  if (frame) {\n    var parsedFrame = /@([^@]+):(\\d+):(\\d+)/.exec(frame);\n\n    if (parsedFrame) {\n      var _parsedFrame = _slicedToArray(parsedFrame, 4),\n          file = _parsedFrame[1],\n          line = _parsedFrame[2],\n          col = _parsedFrame[3];\n\n      return [file, Number(line), Number(col)];\n    }\n  }\n\n  return ['unknown', 0, 0];\n}\n\nfunction processStack(stack) {\n  var workletStackEntries = stack.match(/worklet_(\\d+):(\\d+):(\\d+)/g);\n  var result = stack;\n  workletStackEntries === null || workletStackEntries === void 0 ? void 0 : workletStackEntries.forEach(function (match) {\n    var _match$split$map = match.split(/:|_/).map(Number),\n        _match$split$map2 = _slicedToArray(_match$split$map, 4),\n        hash = _match$split$map2[1],\n        origLine = _match$split$map2[2],\n        origCol = _match$split$map2[3];\n\n    var errorDetails = _workletStackDetails.get(hash);\n\n    if (!errorDetails) {\n      return;\n    }\n\n    var _errorDetails = _slicedToArray(errorDetails, 3),\n        error = _errorDetails[0],\n        lineOffset = _errorDetails[1],\n        colOffset = _errorDetails[2];\n\n    var _getBundleOffset = getBundleOffset(error),\n        _getBundleOffset2 = _slicedToArray(_getBundleOffset, 3),\n        bundleFile = _getBundleOffset2[0],\n        bundleLine = _getBundleOffset2[1],\n        bundleCol = _getBundleOffset2[2];\n\n    var line = origLine + bundleLine + lineOffset;\n    var col = origCol + bundleCol + colOffset;\n    result = result.replace(match, `${bundleFile}:${line}:${col}`);\n  });\n  return result;\n}\n\nexport function reportFatalErrorOnJS(_ref) {\n  var message = _ref.message,\n      stack = _ref.stack;\n  var error = new Error();\n  error.message = message;\n  error.stack = stack ? processStack(stack) : undefined;\n  error.name = 'ReanimatedError';\n  error.jsEngine = 'reanimated';\n  global.ErrorUtils.reportFatalError(error);\n}","map":{"version":3,"sources":["errors.ts"],"names":["_workletStackDetails","Map","registerWorkletStackDetails","hash","stackDetails","set","getBundleOffset","error","frame","stack","split","parsedFrame","exec","file","line","col","Number","processStack","workletStackEntries","match","result","forEach","origLine","origCol","map","errorDetails","get","lineOffset","colOffset","bundleFile","bundleLine","bundleCol","replace","reportFatalErrorOnJS","message","Error","undefined","name","jsEngine","global","ErrorUtils","reportFatalError"],"mappings":";;AAEA,IAAMA,oBAAoB,GAAG,IAAIC,GAAJ,EAA7B;;AAEA,OAAO,SAASC,2BAAT,CACLC,IADK,EAELC,YAFK,EAGL;EACAJ,oBAAoB,CAACK,GAArBL,CAAyBG,IAAzBH,EAA+BI,YAA/BJ;AACF;;AAEA,SAASM,eAAT,CAAyBC,KAAzB,EAAiE;EAAA,IAAA,YAAA,EAAA,kBAAA;;EAC/D,IAAMC,KAAK,GAAA,CAAA,YAAA,GAAGD,KAAK,CAACE,KAAT,MAAc,IAAd,IAAc,YAAA,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAc,CAAA,kBAAA,GAAXF,YAAAA,CAAaG,KAAbH,CAAmB,IAAnBA,CAAW,MAAa,IAAb,IAAa,kBAAA,KAAA,KAAA,CAAb,GAAa,KAAA,CAAb,GAAXA,kBAAAA,CAA2B,CAA3BA,CAAd;;EACA,IAAIC,KAAJ,EAAW;IACT,IAAMG,WAAW,GAAG,uBAAuBC,IAAvB,CAA4BJ,KAA5B,CAApB;;IACA,IAAIG,WAAJ,EAAiB;MACf,kCAA4BA,WAA5B;MAAA,IAASE,IAAT;MAAA,IAAeC,IAAf;MAAA,IAAqBC,GAArB;;MACA,OAAO,CAACF,IAAD,EAAOG,MAAM,CAACF,IAAD,CAAb,EAAqBE,MAAM,CAACD,GAAD,CAA3B,CAAP;IACF;EACF;;EACA,OAAO,CAAC,SAAD,EAAY,CAAZ,EAAe,CAAf,CAAP;AACF;;AAEA,SAASE,YAAT,CAAsBR,KAAtB,EAA6C;EAC3C,IAAMS,mBAAmB,GAAGT,KAAK,CAACU,KAANV,CAAY,4BAAZA,CAA5B;EACA,IAAIW,MAAM,GAAGX,KAAb;EACAS,mBAAmB,KAAA,IAAnBA,IAAAA,mBAAmB,KAAA,KAAA,CAAnBA,GAAmB,KAAA,CAAnBA,GAAAA,mBAAmB,CAAEG,OAArBH,CAA8BC,UAAAA,KAAK,EAAK;IACtC,uBAAoCA,KAAK,CAACT,KAANS,CAAY,KAAZA,EAAmBK,GAAnBL,CAAuBH,MAAvBG,CAApC;IAAA;IAAA,IAAShB,IAAT;IAAA,IAAemB,QAAf;IAAA,IAAyBC,OAAzB;;IACA,IAAME,YAAY,GAAGzB,oBAAoB,CAAC0B,GAArB1B,CAAyBG,IAAzBH,CAArB;;IACA,IAAI,CAACyB,YAAL,EAAmB;MACjB;IACF;;IACA,mCAAuCA,YAAvC;IAAA,IAAOlB,KAAP;IAAA,IAAcoB,UAAd;IAAA,IAA0BC,SAA1B;;IACA,uBAA4CtB,eAAe,CAACC,KAAD,CAA3D;IAAA;IAAA,IAAOsB,UAAP;IAAA,IAAmBC,UAAnB;IAAA,IAA+BC,SAA/B;;IACA,IAAMjB,IAAI,GAAGQ,QAAQ,GAAGQ,UAAXR,GAAwBK,UAArC;IACA,IAAMZ,GAAG,GAAGQ,OAAO,GAAGQ,SAAVR,GAAsBK,SAAlC;IAEAR,MAAM,GAAGA,MAAM,CAACY,OAAPZ,CAAeD,KAAfC,EAAuB,GAAES,UAAW,IAAGf,IAAK,IAAGC,GAAI,EAAnDK,CAATA;EACD,CAZDF,CAAAA;EAaA,OAAOE,MAAP;AACF;;AAEA,OAAO,SAASa,oBAAT,CAA6BA,IAA7B,EAMJ;EANkC,IACnCC,OADmC,GAMpC,IANoC,CACnCA,OADmC;EAAA,IAEnCzB,KAFmC,GAMpC,IANoC,CAEnCA,KAFmC;EAOnC,IAAMF,KAAK,GAAG,IAAI4B,KAAJ,EAAd;EACA5B,KAAK,CAAC2B,OAAN3B,GAAgB2B,OAAhB3B;EACAA,KAAK,CAACE,KAANF,GAAcE,KAAK,GAAGQ,YAAY,CAACR,KAAD,CAAf,GAAyB2B,SAA5C7B;EACAA,KAAK,CAAC8B,IAAN9B,GAAa,iBAAbA;EAEAA,KAAK,CAAC+B,QAAN/B,GAAiB,YAAjBA;EAEAgC,MAAM,CAACC,UAAPD,CAAkBE,gBAAlBF,CAAmChC,KAAnCgC;AACF","sourcesContent":["type StackDetails = [Error, number, number];\n\nconst _workletStackDetails = new Map<number, StackDetails>();\n\nexport function registerWorkletStackDetails(\n  hash: number,\n  stackDetails: StackDetails\n) {\n  _workletStackDetails.set(hash, stackDetails);\n}\n\nfunction getBundleOffset(error: Error): [string, number, number] {\n  const frame = error.stack?.split('\\n')?.[0];\n  if (frame) {\n    const parsedFrame = /@([^@]+):(\\d+):(\\d+)/.exec(frame);\n    if (parsedFrame) {\n      const [, file, line, col] = parsedFrame;\n      return [file, Number(line), Number(col)];\n    }\n  }\n  return ['unknown', 0, 0];\n}\n\nfunction processStack(stack: string): string {\n  const workletStackEntries = stack.match(/worklet_(\\d+):(\\d+):(\\d+)/g);\n  let result = stack;\n  workletStackEntries?.forEach((match) => {\n    const [, hash, origLine, origCol] = match.split(/:|_/).map(Number);\n    const errorDetails = _workletStackDetails.get(hash);\n    if (!errorDetails) {\n      return;\n    }\n    const [error, lineOffset, colOffset] = errorDetails;\n    const [bundleFile, bundleLine, bundleCol] = getBundleOffset(error);\n    const line = origLine + bundleLine + lineOffset;\n    const col = origCol + bundleCol + colOffset;\n\n    result = result.replace(match, `${bundleFile}:${line}:${col}`);\n  });\n  return result;\n}\n\nexport function reportFatalErrorOnJS({\n  message,\n  stack,\n}: {\n  message: string;\n  stack?: string;\n}) {\n  const error = new Error();\n  error.message = message;\n  error.stack = stack ? processStack(stack) : undefined;\n  error.name = 'ReanimatedError';\n  // @ts-ignore React Native's ErrorUtils implementation extends the Error type with jsEngine field\n  error.jsEngine = 'reanimated';\n  // @ts-ignore the reportFatalError method is an internal method of ErrorUtils not exposed in the type definitions\n  global.ErrorUtils.reportFatalError(error);\n}\n"]},"metadata":{},"sourceType":"module"}